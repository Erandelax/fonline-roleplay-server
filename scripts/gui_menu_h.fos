// by Erandelax aka Sjaman 24/10/2018
funcdef void MenuActionCallback(int,int,MenuAction@);

#include "gui_h.fos"
#include "_client_defines.fos"

interface MenuItem
{
	void Click(int,int);
	
	bool IsStatic();
	bool IsExpanded();

	string GetTitle();
	string GetIcon();
	int    GetSize();
	MenuItem@ GetItem(uint,uint&);
	MenuItem@ GetItem(uint);

	void SetExpanded(bool);
}

class MenuAction : MenuItem
{
	protected string Title;
	protected MenuActionCallback@ Action;

	string GetTitle() {
		return this.Title;
	}	

	string GetIcon() {
		return "";
	}

	int GetSize() {
		return 1;
	}

	MenuItem@ GetItem(uint skip, uint& skip2) {
		return cast<MenuItem>(this);
	}

	MenuItem@ GetItem(uint skip) {
		return cast<MenuItem>(this);	
	}

	void SetExpanded(bool state) {
		return;
	}

	bool IsStatic() {
		return null is this.Action;
	}

	bool IsExpanded() {
		return false;
	}

	void Click(int X, int Y) {
		Message("CLICK:"+X+"/"+Y);
	}

	MenuAction(string title, MenuActionCallback@ action) {
		this.Title = title;
		@this.Action = @action;
	}

	MenuAction(string title, MenuAction@ menuAction) {
		this.Title = title;
		@this.Action = @menuAction.Action;
	}

	MenuAction(string title) {
		this.Title = title;
	}
}

class Menu : MenuItem
{
	protected string Title;
	protected MenuItem@[] Items;
	protected bool Expanded = true;

	MenuItem@ GetItem(uint id, uint& depth) {
		/* Don't ask me how it works. Black recursive magic
			- item (0 <=> 0), size 1
			- submenu (1 <=> 1), size 3
				= subitem (1:0 <=> 2), size 1
				= subitem (1:1 <=> 3), size 1
			- item (2 <=> 4), size 1
			- submenu (3 <=> 5), size 3
				= subitem (3:0 <=> 6), size 1
				= subitem (3:1 <=> 7), size 1
			- item (4 <=> 8), size 1
			- item (5 <=> 9), size 1
		*/
		uint pos = 0, parentPos = 0, nextParentPos = 0, size = 0, lastPos = 0;
		while (pos < this.Items.length && parentPos != id && nextParentPos < id) {
			parentPos = nextParentPos;
			lastPos = pos;
			size = this.Items[pos].GetSize();
			nextParentPos += size;
			pos++;
		}
		if (nextParentPos == id) {
			return this.Items[pos];
		} 
		else {
			depth++;
			return this.Items[lastPos].GetItem(id - parentPos - 1, depth);
		}
	}

	MenuItem@ GetItem(uint id) {
		uint skip = 0;
		return this.GetItem(id,skip);
	}

	int GetSize() {
		int result = 1;
		if (this.IsExpanded()) {
			for (uint i = 0; i < this.Items.length; i++) {
				result += this.Items[i].GetSize();
			}
		} 
		return result;
	}

	string GetTitle() {
		return this.Title;
	}

	string GetIcon() {
		return "";
	}

	void SetExpanded(bool state) {
		this.Expanded = state;
	}

	Menu@ Add(string title) {
		return this.Add(MenuAction(title));
	}

	Menu@ Add(MenuItem@ item) {
		item.SetExpanded(false);
		this.Items.insertLast(item);
		return this;
	}

	void Popup(int X, int Y) {
		GUIPopupMenu::Init(X,Y,@this);
	}

	void Click(int X, int Y) {
		this.SetExpanded(!this.Expanded);
	}

	bool IsExpanded() {
		return this.Expanded;
	}

	bool IsStatic() {
		return 0 == this.Items.length;
	}

	Menu(string title) {
		this.Title = title;
		this.Items.resize(0);
	}
}

namespace GUIPopupMenu 
{
	void Init(int X, int Y, Menu@ menu) {
		// Get existing or create new popup menu screen
		MenuScreen@ _screen = cast<MenuScreen>( GUI_GetScreen(CLIENT_SCREEN_POPUP_MENU) );

		if (_screen is null) {
			@_screen = MenuScreen();
			_screen.Init(null);
			GUI_RegisterScreen(CLIENT_SCREEN_POPUP_MENU, _screen);
		}

		// Fill it with data
		MenuGrid  _grid();
		MenuItem  _item();
		MenuLabel _label();
		MenuIcon  _icon();
		_label.Init(_item);
		_icon.Init(_item);	
		_item.Init(_grid);
		_grid.Init(_screen);
		_grid.SetPosition(X,Y);	
		_grid.SetMenu(@menu);		

		ShowScreen(CLIENT_SCREEN_POPUP_MENU);
	}

	class MenuScreen : GUIScreen
	{
		void OnConstruct() override {
			SetPosition(0,0);
			SetDock(DOCK_FILL);
			SetSize(__ScreenWidth,__ScreenHeight);
		}

		void OnMouseDown(int button) override {
			HideScreen(CLIENT_SCREEN_POPUP_MENU);
			while (this._Children.length > 0) this._Children[0].Remove();
		}
	}

	class MenuGrid : GUIGrid
	{
		::Menu@ Menu;
		bool Scrollable = false;
		int ScrollOffset = 0;
		int ScrollLimit = 0;
		int ScrollRange = 12;

		void OnConstruct() override {
			this.SetCellPrototype("MenuItem");
		}

		void SetMenu(::Menu@ menu) {
			@this.Menu = menu;
			int size = menu.GetSize();
			this.Update();
		}

		void Update() {
			if (null !is this.Menu) {
				int size = this.Menu.GetSize();
				if (size <= this.ScrollRange) {
					this.Scrollable = false;
					this.ScrollLimit = size;
					this.ResizeGrid(size);
					return;
				}
				this.Scrollable = true;
				this.ScrollLimit = size - this.ScrollRange;
			}
			this.ResizeGrid(this.ScrollRange);
		}
	}

	class MenuItem : GUIPanel
	{
		bool Static = false;

		void OnConstruct() override {
			this.SetSize(100,13);
		}

		void OnMouseDown(int button) override {
			MenuGrid@ parent = cast<MenuGrid>(Parent);
			if (MOUSE_BUTTON_WHEEL_UP == button || MOUSE_BUTTON_WHEEL_DOWN == button) {
				if (parent.Scrollable) {
					if (MOUSE_BUTTON_WHEEL_UP == button) {
						if (parent.ScrollOffset > 0) {
							parent.ScrollOffset--;
							parent.Update();
						}
					} 
					else {
						if (parent.ScrollOffset < parent.ScrollLimit - 1) {
							parent.ScrollOffset++;
							parent.Update(); 
						}
					}
				}
			} 
			else {
				::MenuItem@ item = parent.Menu.GetItem(parent.ScrollOffset + this.CellIndex);
				if (null !is item && !this.Static) {
					item.Click(_AbsolutePosX, _AbsolutePosY);
					parent.Update();
				}
			}
		}

		void OnResizeGrid( GUIObject@ cell, uint cellIndex ) override {
			MenuGrid@ parent = cast<MenuGrid>(Parent);
			MenuLabel@ label = cast<MenuLabel>( this.Find("MenuLabel") );
			if (null !is parent.Menu) {
				uint depth = 0;
				::MenuItem@ item = parent.Menu.GetItem(parent.ScrollOffset + cellIndex, depth);	
				this.Static = item.IsStatic();
				label.SetText( item.GetTitle() );
				label.SetPosition(depth * 12,0);

				if (this.Static) {
					label.SetTextColor( COLOR_RED );
				}
			}
		}

		void OnHoverChanged() override {
			MenuLabel@ label = cast<MenuLabel>(Find("MenuLabel"));

			if (this.IsHovered) {
				label.SetTextColor( COLOR_WHITE );
			}
			else {
				label.SetTextColor( this.Static ? COLOR_RED : COLOR_GREEN );
			}
		}
	}

	class MenuLabel : GUIText 
	{
		void OnConstruct() override {
			this.SetNotHittable(true);
			this.SetSize(Parent.Width, Parent.Height);
			this.SetTextFlags(FT_BORDERED|FT_CENTERY);
	        this.SetTextColor(COLOR_GREEN);
	        this.SetText("<menu item>");
		}

		void OnResizeGrid( GUIObject@ cell, uint cellIndex ) override {
			Message("PANEL " + cellIndex);
		}
	}

	class MenuIcon : GUIPanel
	{
		void OnConstruct() override {
			this.SetNotHittable( true );
			this.SetSize(0,0);
		}
	}
}